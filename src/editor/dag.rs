//! Code for an editable, undoable forest of syntax trees.

use crate::arena::Arena;
use crate::ast;
use crate::ast::Ast;
use crate::editor::normal_mode::Action;

use crate::core::{Direction, Path, Side};

/// The two possible locations where an edit could cause nodes to be replaced
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum EditLocation {
    /// The edit caused the cursor to be replaced
    Cursor = 0,
    /// The edit caused the parent to be replaced
    Parent = 1,
}

impl EditLocation {
    /// How many steps above the cursor was the edit made
    #[inline]
    fn steps_above_cursor(self) -> usize {
        self as usize
    }
}

/// An enum that's returned when any of the 'edit' methods in [`DAG`] are successful.
#[allow(missing_docs)]
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum EditSuccess {
    Undo,
    Redo,
    Move(Direction),
    Replace { c: char, name: String },
    InsertChild { c: char, name: String },
    InsertNextToCursor { side: Side, c: char, name: String },
    Delete { name: String },
}

impl EditSuccess {
    /// Writes an info message of a successful action using `info!`
    fn log_message(self) {
        match self {
            EditSuccess::Undo => log::info!("Undoing one change"),
            EditSuccess::Redo => log::info!("Redoing one change"),
            EditSuccess::Move(Direction::Up) => log::info!("Moving up the tree"),
            EditSuccess::Move(Direction::Down) => log::info!("Moving down the tree"),
            EditSuccess::Move(Direction::Prev) => log::info!("Moving to previous child"),
            EditSuccess::Move(Direction::Next) => log::info!("Moving to next child"),
            EditSuccess::Replace { c, name } => log::info!("Replacing with '{}'/{}", c, name),
            EditSuccess::InsertChild { c, name } => {
                log::info!("Inserting '{}'/{} as new child", c, name)
            }
            EditSuccess::InsertNextToCursor { side, c, name } => log::info!(
                "Inserting '{}'/{} {} the cursor",
                c,
                name,
                side.relational_word()
            ),
            EditSuccess::Delete { name } => log::info!("Deleting {}", name),
        }
    }
}

/// An error that represents an error in any of the 'edit' methods in [`DAG`].
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum EditErr {
    /* MOVEMENT ERRORS */
    /// Trying to move to the child of a node with no children
    MoveToNonexistentChild,
    /// Trying to move to the parent of the root
    MoveToParentOfRoot,
    /// Trying to move to a sibling that doesn't exist
    MoveToNonexistentSibling,
    /// Trying to move to a sibling of the root
    MoveToSiblingOfRoot,

    /* EDITING ERRORS */
    /// Trying to undo the earliest change
    NoChangesToUndo,
    /// Trying to redo the latest change
    NoChangesToRedo,
    /// The user typed a char that doesn't correspond to any node
    CharNotANode(char),
    /// Trying to insert a node that cannot be a child of the cursor
    CannotBeChild {
        /// The [`char`] representing the disallowed child type
        c: char,
        /// The [`display_name`](Ast::display_name) of the parent node
        parent_name: String,
    },
    /// An error was generated by the Ast code when trying to insert a node
    InsertError(ast::InsertError),
    /// An error was generated by the Ast code when trying to delete a node
    DeleteError(ast::DeleteError),
    /// Trying to add a sibling to the root
    AddSiblingToRoot,
    /// Trying to delete the root
    DeletingRoot,
}

impl EditErr {
    /// Writes an warning message of the encountered error using either `warn!` or `error!`,
    /// depending on the severity of the error
    fn log_message(self) {
        match self {
            EditErr::MoveToNonexistentChild => {
                log::warn!("Can't move down if the cursor has no children.")
            }
            EditErr::MoveToNonexistentSibling => {
                log::warn!("Can't move to a non-existent sibling.")
            }
            EditErr::MoveToParentOfRoot => log::warn!("Can't move to the parent of the root."),
            EditErr::MoveToSiblingOfRoot => log::warn!("Can't move to a sibling of the root."),
            EditErr::NoChangesToUndo => log::warn!("No changes to undo."),
            EditErr::NoChangesToRedo => log::warn!("No changes to redo."),
            EditErr::InsertError(e) => log::warn!("{}", e),
            EditErr::DeleteError(e) => log::warn!("{}", e),
            EditErr::CharNotANode(c) => log::warn!("'{}' doesn't correspond to any node type.", c),
            EditErr::CannotBeChild { c, parent_name } => {
                log::warn!("'{}' cannot be a child of {}", c, parent_name)
            }
            EditErr::AddSiblingToRoot => log::warn!("Can't add siblings to the root."),
            EditErr::DeletingRoot => log::warn!("Can't delete the root."),
        }
    }
}

impl From<ast::InsertError> for EditErr {
    fn from(e: ast::InsertError) -> EditErr {
        EditErr::InsertError(e)
    }
}

impl From<ast::DeleteError> for EditErr {
    fn from(e: ast::DeleteError) -> EditErr {
        EditErr::DeleteError(e)
    }
}

/// An alias for [`Result`] that is the return type of all of [`DAG`]'s edit methods.
pub type EditResult = Result<EditSuccess, EditErr>;

/// A trait-extension that provides a convenient way convert [`EditResult`]s into log messages.
pub trait LogMessage {
    /// Log the current result's message to the appropriate log channel.
    fn log_message(self);
}

impl LogMessage for EditResult {
    /// Consumes this `EditResult` and logs an appropriate summary report (using `info!` for
    /// [`EditSuccess`]es and `warn!` or `error!` for [`EditErr`]s).
    fn log_message(self) {
        match self {
            Ok(ok) => ok.log_message(),
            Err(err) => err.log_message(),
        }
    }
}

/// A datastructure that stores the history of a tree as a DAG (Directed Acyclic Graph) of
/// **immutable** nodes.
///
/// This means that every node that has ever been created exists somewhere in the DAG, and when
/// changes are made, every ancestor of that node is cloned until the root is reached and that
/// root becomes the new 'current' root.  This is very similar to the way Git handles commits -
/// each node is like a file/directory and each root is a commit.
///
/// Therefore, moving back through the history is as simple as reading a different root node from
/// the `roots` vector, and following its descendants through the DAG of nodes.
pub struct DAG<'arena, Node: Ast<'arena>> {
    /// The arena in which all the `Node`s will be stored
    arena: &'arena Arena<Node>,
    /// A [`Vec`] containing a reference to the root node at every edit in the undo history.  This
    /// is required to always have length at least one.
    root_history: Vec<(&'arena Node, Path)>,
    /// An index into [`root_history`](DAG::root_history) of the current edit.  This is required to
    /// be in `0..root_history.len()`.
    history_index: usize,
    current_cursor_path: Path,
}

impl<'arena, Node: Ast<'arena>> DAG<'arena, Node> {
    /// Builds a new `DAG`, given the tree it should contain
    pub fn new(arena: &'arena Arena<Node>, root: &'arena Node, cursor_path: Path) -> Self {
        DAG {
            arena,
            root_history: vec![(root, cursor_path.clone())],
            history_index: 0,
            current_cursor_path: cursor_path,
        }
    }

    /* NAVIGATION METHODS */

    /// Returns a reference to the node that is currently the root of the AST.
    pub fn root(&self) -> &'arena Node {
        // This indexing shouldn't panic because we require that `self.history_index` is a valid index
        // into `self.root_history`, and `self.root_history` has at least one element
        self.root_history[self.history_index].0
    }

    /// Returns the cursor node and its direct parent (if such a parent exists)
    pub fn cursor_and_parent(&self) -> (&'arena Node, Option<&'arena Node>) {
        self.current_cursor_path.cursor_and_parent(self.root())
    }

    /// Returns a reference to the node that is currently under the cursor.
    pub fn cursor(&self) -> &'arena Node {
        self.current_cursor_path.cursor(self.root())
    }

    /// Move the cursor in a given direction across the tree.  Returns [`Some`] error string if an
    /// error is found, or [`None`] if the movement was possible.
    pub fn move_cursor(&mut self, direction: Direction) -> EditResult {
        let (current_cursor, cursor_parent) = self.cursor_and_parent();
        match direction {
            Direction::Down => {
                if current_cursor.children().is_empty() {
                    return Err(EditErr::MoveToNonexistentChild);
                }
                self.current_cursor_path.push(0);
            }
            Direction::Up => {
                if self.current_cursor_path.is_root() {
                    return Err(EditErr::MoveToParentOfRoot);
                }
                self.current_cursor_path.pop();
            }
            Direction::Prev => {
                let index = self
                    .current_cursor_path
                    .last_mut()
                    .ok_or(EditErr::MoveToSiblingOfRoot)?;
                if *index == 0 {
                    return Err(EditErr::MoveToNonexistentSibling);
                }
                *index -= 1;
            }
            Direction::Next => {
                let last_index = self
                    .current_cursor_path
                    .last_mut()
                    .ok_or(EditErr::MoveToSiblingOfRoot)?;
                // We can unwrap here, because the only way for a node to not have a parent is
                // if it's the root.  And if the cursor is at the root, then the `if let` would
                // have failed and this code would not be run.
                if *last_index + 1 >= cursor_parent.unwrap().children().len() {
                    return Err(EditErr::MoveToNonexistentSibling);
                }
                *last_index += 1;
            }
        }
        Ok(EditSuccess::Move(direction))
    }

    /* HISTORY METHODS */

    /// Move one step back in the tree history
    pub fn undo(&mut self) -> EditResult {
        log::trace!("Performing undo.");
        // Early return if there are no changes to undo
        if self.history_index == 0 {
            return Err(EditErr::NoChangesToUndo);
        }
        // Move the history index back by one to perform the undo
        self.history_index -= 1;
        // Follow the behaviour of other text editors and update the location of the cursor
        // with its location in the snapshot we are going forward to
        self.current_cursor_path
            .clone_from(&self.root_history[self.history_index].1);
        log::debug!("Setting cursor path to {:?}", self.current_cursor_path);
        Ok(EditSuccess::Undo)
    }

    /// Move one step forward in the tree history
    pub fn redo(&mut self) -> EditResult {
        log::trace!("Performing redo.");
        // Early return if there are no changes to redo
        if self.history_index >= self.root_history.len() - 1 {
            return Err(EditErr::NoChangesToRedo);
        }
        // Move the history index forward by one to perform the redo
        self.history_index += 1;
        // Follow the behaviour of other text editors and update the location of the cursor
        // with its location in the snapshot we are going back to
        self.current_cursor_path
            .clone_from(&self.root_history[self.history_index].1);
        log::debug!("Setting cursor path to {:?}", self.current_cursor_path);
        Ok(EditSuccess::Redo)
    }

    /* EDITING METHODS */

    fn perform_edit(
        &mut self,
        mut edit_func: impl FnMut(
            &mut Self,
            Option<(&'arena Node, usize)>,
            &'arena Node,
        ) -> Result<(Node, EditLocation, EditSuccess), EditErr>,
    ) -> EditResult {
        // Generate a vec of pointers to the nodes that we will have to clone.  We have to store
        // this as a vec because the iterator that produces them (cursor_path::NodeIter) can only
        // yield values from the root downwards, whereas we need the nodes in the opposite order.
        let nodes_to_clone: Vec<&Node> = self.current_cursor_path.node_iter(self.root()).collect();
        let old_cursor_path: Path = self.current_cursor_path.clone();

        // Unwrap is safe because `nodes_to_clone` must always contain at least the root
        let mut reverse_node_iter = nodes_to_clone.iter().copied().rev();
        let cursor = reverse_node_iter.next().unwrap();
        // Unwrapping in the closure is safe, because if the cursor does have a parent, then the
        // cursor_path must have at least one element
        let parent_and_index = reverse_node_iter
            .next()
            .map(|node| (node, old_cursor_path.last().unwrap()));

        /* PERFORM THE EDIT */

        let (new_node, edit_location, success) = edit_func(self, parent_and_index, cursor)?;
        let steps_above_cursor = edit_location.steps_above_cursor();

        /* CLONE ALL THE PARENT NODES TO GET A NEW ROOT */

        // Because AST nodes are immutable, we make changes to nodes by entirely cloning the path
        // down to the node under the cursor.  We do this starting at the node under the cursor and
        // work our way up parent by parent until we reach the root of the tree.  At that point,
        // this node becomes the root of the new tree.
        let mut node = self.arena.alloc(new_node);
        // Iterate backwards over the child indices and the nodes, whilst cloning the tree and
        // replacing the correct child reference to point to the newly created node.
        for (n, child_index) in nodes_to_clone
            .iter()
            .rev()
            .skip(1)
            .zip(old_cursor_path.iter().rev())
            .skip(steps_above_cursor)
        {
            let mut cloned_node = (*n).clone();
            cloned_node.children_mut()[*child_index] = node;
            node = self.arena.alloc(cloned_node);
        }

        /* UPDATE THE HISTORY */

        // Remove future trees from the history vector so that the currently 'checked-out' tree is
        // the most recent tree in the history.
        while self.history_index < self.root_history.len() - 1 {
            // TODO: Deallocate the tree so that we don't get a 'memory leak'
            self.root_history.pop();
        }
        // At this point, `node` contains a reference to the root of the new tree, so we just add
        // this to the history, along with the cursor path.
        self.root_history
            .push((node, self.current_cursor_path.clone()));
        // Move the history index on by one so that we are pointing at the latest change
        self.history_index = self.root_history.len() - 1;

        /* RETURN SUCCESS */
        Ok(success)
    }

    /// Replaces the current cursor with a node represented by `c`
    fn replace_cursor(&mut self, c: char) -> EditResult {
        self.perform_edit(
            |_this: &mut Self,
             _parent_and_index: Option<(&'arena Node, usize)>,
             cursor: &'arena Node| {
                match _parent_and_index {
                    Some((parent, cursor_index)) => {
                        if !parent.is_valid_child(cursor_index, c) {
                            return Err(EditErr::CannotBeChild {
                                c,
                                parent_name: _parent_and_index
                                    .map_or("<root>".to_string(), |(p, _)| p.display_name()),
                            });
                        }
                    }
                    None => {
                        if !cursor.is_valid_root(c) {
                            return Err(EditErr::CharNotANode(c));
                        }
                    }
                }
                // Create the node to replace
                // we can use unwrap here, because 'c' is always one of valid chars.
                let new_node = cursor.from_char(c).unwrap();
                let new_node_name = new_node.display_name();
                Ok((
                    new_node,
                    EditLocation::Cursor,
                    EditSuccess::Replace {
                        c,
                        name: new_node_name,
                    },
                ))
            },
        )
    }

    /// Updates the internal state so that the tree now contains `new_node` inserted as the last
    /// child of the selected node.  Also moves the cursor so that the new node is selected.
    fn insert_child(&mut self, c: char) -> EditResult {
        self.perform_edit(
            |this: &mut Self,
             _parent_and_index: Option<(&'arena Node, usize)>,
             cursor: &'arena Node| {
                match _parent_and_index {
                    Some((parent, cursor_index)) => {
                        if !parent.is_valid_child(cursor_index, c) {
                            // Short circuit if `c` couldn't be a valid child of the cursor
                            return Err(EditErr::CannotBeChild {
                                c,
                                parent_name: cursor.display_name(),
                            });
                        }
                    }
                    None => {
                        // Short circuit if `c` couldn't be a valid child of the cursor
                        if !cursor.is_valid_root(c) {
                            return Err(EditErr::CharNotANode(c));
                        }
                    }
                }
                // Create the node to insert
                // we can use unwrap here, because 'c' is always one of valid chars.
                let new_node = this.arena.alloc(cursor.from_char(c).unwrap());
                let new_node_name = new_node.display_name();
                // Clone the node that currently is the cursor, and add the new child to the end of its
                // children.
                let mut cloned_cursor = cursor.clone();
                // Store the new_node's display name before it's consumed by `finish_edit`
                // Add the new child to the children of the cloned cursor
                cloned_cursor.insert_child(new_node, this.arena, cloned_cursor.children().len())?;

                // moves the cursor to the newly added child
                this.current_cursor_path.push(cursor.children().len());

                Ok((
                    cloned_cursor,
                    EditLocation::Cursor,
                    EditSuccess::InsertChild {
                        c,
                        name: new_node_name,
                    },
                ))
            },
        )
    }

    /// Updates the internal state so that the tree now contains `new_node` inserted as the first
    /// child of the selected node.  Also moves the cursor so that the new node is selected.
    fn insert_next_to_cursor(&mut self, c: char, side: Side) -> EditResult {
        self.perform_edit(
            |this: &mut Self,
             parent_and_index: Option<(&'arena Node, usize)>,
             _cursor: &'arena Node| {
                // Find (and cache) the parent of the cursor.  If the parent of the cursor doesn't exist,
                // the cursor must be the root and we can't insert a node next to the root.
                let (parent, cursor_index) = parent_and_index.ok_or(EditErr::AddSiblingToRoot)?;

                // Short circuit if not an insertable char
                if !parent.is_valid_child(cursor_index, c) {
                    return Err(EditErr::CannotBeChild {
                        c,
                        parent_name: parent.display_name(),
                    });
                }

                let insert_index = cursor_index
                    + match side {
                        Side::Prev => 0,
                        Side::Next => 1,
                    };
                let mut cloned_parent = parent.clone();
                // Create the new sibling node according to the given char.
                let new_node = this
                    .arena
                    .alloc(cloned_parent.from_char(c).ok_or(EditErr::CharNotANode(c))?);
                // Store the new_node's display name before it's consumed by `insert_child`
                let new_node_name = new_node.display_name();
                // Add the new child to the children of the cloned cursor
                cloned_parent.insert_child(new_node, this.arena, insert_index)?;
                // move the cursor to the correct location, we can unwrap it here, because we
                // know we will not insert sibling to root node
                *this.current_cursor_path.last_mut().unwrap() = insert_index;
                // Return the success
                Ok((
                    cloned_parent,
                    EditLocation::Parent,
                    EditSuccess::InsertNextToCursor {
                        side,
                        c,
                        name: new_node_name,
                    },
                ))
            },
        )
    }

    fn delete_cursor(&mut self) -> EditResult {
        self.perform_edit(
            |this: &mut Self,
             parent_and_index: Option<(&'arena Node, usize)>,
             cursor: &'arena Node| {
                // Find (and cache) the parent of the cursor.  If the parent of the cursor doesn't exist,
                // the cursor must be the root and we can't delete the root.
                let (parent, cursor_index) = parent_and_index.ok_or(EditErr::DeletingRoot)?;
                // Cache the name of the cursor **before** it gets deleted
                let deleted_node_name = cursor.display_name();

                let mut cloned_parent = parent.clone();
                cloned_parent.delete_child(cursor_index)?;

                let new_parents_child_count = cloned_parent.children().len();
                if new_parents_child_count == 0 {
                    // If we remove the only child of a node then we move the cursor up
                    this.current_cursor_path.pop();
                } else if cursor_index == new_parents_child_count {
                    // If we deleted the last child of a node (and this isn't the last child), we move
                    // the cursor back by one.  We can unwrap here because we know we aren't
                    // removing the root
                    *this.current_cursor_path.last_mut().unwrap() -= 1;
                }

                Ok((
                    cloned_parent,
                    EditLocation::Parent,
                    EditSuccess::Delete {
                        name: deleted_node_name,
                    },
                ))
            },
        )
    }

    /// Execute an [`Action`] generated by some keystrokes from the user.
    pub fn execute_action(&mut self, action: Action) -> EditResult {
        match action {
            // History keystrokes
            Action::Undo => self.undo(),
            Action::Redo => self.redo(),
            // Move keystroke
            Action::MoveCursor(direction) => self.move_cursor(direction),
            // Edit keystrokes
            Action::Replace(c) => self.replace_cursor(c),
            Action::InsertChild(c) => self.insert_child(c),
            Action::InsertBefore(c) => self.insert_next_to_cursor(c, Side::Prev),
            Action::InsertAfter(c) => self.insert_next_to_cursor(c, Side::Next),
            Action::Delete => self.delete_cursor(),
        }
    }

    /* DISPLAY METHODS */

    /// Build the text representation of the current tree into the given [`String`]
    pub fn write_text(&self, string: &mut String, format: &Node::FormatStyle) {
        self.root().write_text(string, format);
    }

    /// Build and return a [`String`] of the current tree
    pub fn to_text(&self, format: &Node::FormatStyle) -> String {
        let mut s = String::new();
        self.write_text(&mut s, format);
        s
    }
}

#[cfg(test)]
mod tests {
    use super::{EditErr, EditSuccess};
    use crate::arena::Arena;
    use crate::ast::json::JSON;
    use crate::ast::test_json::TestJSON;
    use crate::core::{Direction, Path, Side};
    use crate::editor::{normal_mode::Action, DAG};

    fn run_test_ok(
        start_tree: TestJSON,
        start_cursor_location: Path,
        action: Action,
        expected_edit_success: EditSuccess,
        expected_tree: TestJSON,
        expected_cursor_location: Path,
    ) {
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location);

        assert_eq!(
            Ok(expected_edit_success),
            editable_tree.execute_action(action),
            "Not equal in action result"
        );
        assert_eq!(expected_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    fn run_test_err(
        start_tree: TestJSON,
        start_cursor_location: Path,
        action: Action,
        expected_edit_err: EditErr,
    ) {
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.clone().add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location.clone());

        assert_eq!(
            Err(expected_edit_err),
            editable_tree.execute_action(action),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            start_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    #[test]
    fn root_insertchild() {
        run_test_ok(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::InsertChild('f'),
            EditSuccess::InsertChild {
                c: 'f',
                name: "false".to_string(),
            },
            TestJSON::Array(vec![TestJSON::False]),
            Path::from_vec(vec![0]),
        );

        //DAG level == 1

        run_test_ok(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::InsertChild('n'),
            EditSuccess::InsertChild {
                c: 'n',
                name: "null".to_string(),
            },
            TestJSON::Array(vec![
                TestJSON::Array(vec![]),
                TestJSON::True,
                TestJSON::Null,
            ]),
            Path::from_vec(vec![2]),
        )
    }

    #[test]
    fn root_insertbefore() {
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::InsertBefore('f'),
            EditErr::AddSiblingToRoot,
        );

        //  tree level == 1
        run_test_err(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::InsertBefore('f'),
            EditErr::AddSiblingToRoot,
        );
    }

    #[test]
    fn root_insertafter() {
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::InsertAfter('f'),
            EditErr::AddSiblingToRoot,
        );

        // tree level == 1
        run_test_err(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::InsertAfter('f'),
            EditErr::AddSiblingToRoot,
        );
    }

    #[test]
    fn root_replace() {
        run_test_ok(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::Replace('f'),
            EditSuccess::Replace {
                c: 'f',
                name: "false".to_string(),
            },
            TestJSON::False,
            Path::root(),
        );

        // Char not a node
        run_test_err(
            TestJSON::False,
            Path::root(),
            Action::Replace('m'),
            EditErr::CharNotANode('m'),
        );
        //
        // tree level == 1
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Array(vec![])]),
            Path::root(),
            Action::Replace('n'),
            EditSuccess::Replace {
                c: 'n',
                name: "null".to_string(),
            },
            TestJSON::Null,
            Path::root(),
        );
    }

    #[test]
    fn root_delete() {
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::Delete,
            EditErr::DeletingRoot,
        );

        // dag level==1
        run_test_err(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::Delete,
            EditErr::DeletingRoot,
        );
    }

    #[test]
    fn root_movecursor() {
        // move to previous sibling node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Prev),
            EditErr::MoveToSiblingOfRoot,
        );
        // move to next sibling node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Next),
            EditErr::MoveToSiblingOfRoot,
        );
        // move to parent node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Up),
            EditErr::MoveToParentOfRoot,
        );
        // move to nonexistent child node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            EditErr::MoveToNonexistentChild,
        );

        // move to nonexistent child node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            EditErr::MoveToNonexistentChild,
        );
        // move to root from child
        run_test_ok(
            TestJSON::Array(vec![TestJSON::False, TestJSON::True]),
            Path::from_vec(vec![1]),
            Action::MoveCursor(Direction::Up),
            EditSuccess::Move(Direction::Up),
            TestJSON::Array(vec![TestJSON::False, TestJSON::True]),
            Path::root(),
        );
    }

    #[test]
    fn root_undo() {
        let start_tree = TestJSON::Array(vec![]);
        let start_cursor_location = Path::root();
        let end_tree = TestJSON::False;
        let end_cursor_location = Path::root();

        // Initialise the DAG with the `start_tree`
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location.clone());

        // We start with an empty JSON array (`[]`), and we replace it with `false`
        assert_eq!(
            Ok(EditSuccess::Replace {
                c: 'f',
                name: "false".to_string(),
            }),
            editable_tree.execute_action(Action::Replace('f')),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Undo the change
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            start_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        //  DAG level == 1
        let start_tree = TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let start_cursor_location = Path::root();
        // We move the cursor so we expect the cursor to move but no change to occur to the tree
        let end_cursor_location = Path::from_vec(vec![0]);

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location);

        assert_eq!(
            Ok(EditSuccess::Move(Direction::Down)),
            editable_tree.execute_action(Action::MoveCursor(Direction::Down)),
            "Not equal in action result (move 0)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 0)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 0)."
        );

        // undo
        assert_eq!(
            Err(EditErr::NoChangesToUndo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result (move 1)"
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 1)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 1)."
        );
    }

    #[test]
    fn root_redo() {
        let start_tree = TestJSON::Array(vec![]);
        let end_tree = TestJSON::Object(vec![]);

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, Path::root());

        assert_eq!(
            Ok(EditSuccess::Replace {
                c: 'o',
                name: "object".to_string(),
            }),
            editable_tree.execute_action(Action::Replace('o')),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // undo
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // redo
        assert_eq!(
            Ok(EditSuccess::Redo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        //DAG level == 1
        let start_tree = TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let start_cursor_location = Path::root();
        let end_cursor_location = Path::from_vec(vec![0]);

        // Initialise a DAG with the cursor at the root
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, Path::root());

        assert_eq!(
            Ok(EditSuccess::Move(Direction::Down)),
            editable_tree.execute_action(Action::MoveCursor(Direction::Down)),
            "Not equal in action result (move 0)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 0)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 0)."
        );

        // undo
        assert_eq!(
            Err(EditErr::NoChangesToUndo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result (move 1)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 1)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 1). "
        );

        // redo
        assert_eq!(
            Err(EditErr::NoChangesToRedo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result (move 2)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 2)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 2)."
        );
    }

    #[test]
    fn level_1_insertchild() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::from_vec(vec![0]),
            Action::InsertChild('f'),
            EditSuccess::InsertChild {
                c: 'f',
                name: "false".to_string(),
            },
            TestJSON::Array(vec![TestJSON::Array(vec![TestJSON::False]), TestJSON::True]),
            Path::from_vec(vec![0, 0]),
        );
    }

    #[test]
    fn level_1_insertafter() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::True]),
            Path::from_vec(vec![1]),
            Action::InsertAfter('f'),
            EditSuccess::InsertNextToCursor {
                side: Side::Next,
                c: 'f',
                name: "false".to_string(),
            },
            TestJSON::Array(vec![TestJSON::True, TestJSON::True, TestJSON::False]),
            Path::from_vec(vec![2]),
        );

        // DAG level == 2
        run_test_ok(
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
            ]),
            Path::from_vec(vec![1]),
            Action::InsertAfter('f'),
            EditSuccess::InsertNextToCursor {
                side: Side::Next,
                c: 'f',
                name: "false".to_string(),
            },
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
                TestJSON::False,
            ]),
            Path::from_vec(vec![2]),
        );
    }

    #[test]
    fn level_1_insertbefore() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::from_vec(vec![0]),
            Action::InsertBefore('f'),
            EditSuccess::InsertNextToCursor {
                side: Side::Prev,
                c: 'f',
                name: "false".to_string(),
            },
            TestJSON::Array(vec![
                TestJSON::False,
                TestJSON::Array(vec![]),
                TestJSON::True,
            ]),
            Path::from_vec(vec![0]),
        );

        // DAG level == 2
        run_test_ok(
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
            ]),
            Path::from_vec(vec![1]),
            Action::InsertBefore('f'),
            EditSuccess::InsertNextToCursor {
                side: Side::Prev,
                c: 'f',
                name: "false".to_string(),
            },
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::False,
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
            ]),
            Path::from_vec(vec![1]),
        );
    }

    #[test]
    fn level_1_delete() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Array(vec![])]),
            Path::from_vec(vec![1]),
            Action::Delete,
            EditSuccess::Delete {
                name: "array".to_string(),
            },
            TestJSON::Array(vec![TestJSON::True]),
            Path::from_vec(vec![0]),
        );

        run_test_ok(
            TestJSON::Array(vec![TestJSON::True]),
            Path::from_vec(vec![0]),
            Action::Delete,
            EditSuccess::Delete {
                name: "true".to_string(),
            },
            TestJSON::Array(vec![]),
            Path::root(),
        );
    }

    #[test]
    fn level_1_replace() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Array(vec![])]),
            Path::from_vec(vec![1]),
            Action::Replace('n'),
            EditSuccess::Replace {
                c: 'n',
                name: "null".to_string(),
            },
            TestJSON::Array(vec![TestJSON::True, TestJSON::Null]),
            Path::from_vec(vec![1]),
        );

        run_test_ok(
            TestJSON::Object(vec![
                ("key-1".to_string(), TestJSON::False),
                ("key-2".to_string(), TestJSON::True),
            ]),
            Path::from_vec(vec![1, 1]),
            Action::Replace('n'),
            EditSuccess::Replace {
                c: 'n',
                name: "null".to_string(),
            },
            TestJSON::Object(vec![
                ("key-1".to_string(), TestJSON::False),
                ("key-2".to_string(), TestJSON::Null),
            ]),
            Path::from_vec(vec![1, 1]),
        );

        run_test_err(
            TestJSON::Object(vec![
                ("key-1".to_string(), TestJSON::False),
                ("key-2".to_string(), TestJSON::True),
            ]),
            Path::from_vec(vec![1, 0]),
            Action::Replace('n'),
            EditErr::CannotBeChild {
                c: 'n',
                parent_name: ("field".to_string()),
            },
        );
    }

    #[test]
    fn level_1_movecursor() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Object(vec![])]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            EditSuccess::Move(Direction::Down),
            TestJSON::Array(vec![TestJSON::True, TestJSON::Object(vec![])]),
            Path::from_vec(vec![0]),
        );
    }

    #[test]
    fn level_1_undo_and_redo() {
        // The original snapshot of the tree
        let start_tree = TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let end_tree = TestJSON::False;

        // Create and initialise DAG to test
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, Path::root());

        // Step 1: Replace root with `false`
        println!("Inserting `false`");
        assert_eq!(
            Ok(EditSuccess::Replace {
                c: 'f',
                name: "false".to_string(),
            }),
            editable_tree.execute_action(Action::Replace('f')),
            "Not equal in action result."
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Perform one undo.  This be successful, because it's undoing the replace-with-false
        println!("Performing first undo");
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Perform another undo.  This won't be successful, because there's nothing to undo
        println!("Performing the 2nd undo");
        assert_eq!(
            Err(EditErr::NoChangesToUndo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Failed undo modified the tree"
        );
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Failed undo moved the cursor"
        );

        // Redo the change we undid (this should succeed)
        println!("Performing the 1st redo");
        assert_eq!(
            Ok(EditSuccess::Redo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Redo another time, but there are no changes to redo
        println!("Performing the 2nd redo");
        assert_eq!(
            Err(EditErr::NoChangesToRedo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    #[test]
    #[ignore]
    // This is the test cases for issue 27
    fn level_2_undo() {
        // The original snapshot of the tree

        let start_tree = TestJSON::Array(vec![
            TestJSON::Null,
            TestJSON::Object(vec![("key".to_string(), TestJSON::True)]),
            TestJSON::False,
        ]);

        let expected_tree = TestJSON::Array(vec![
            TestJSON::Null,
            TestJSON::Object(vec![]),
            TestJSON::False,
        ]);

        // Create and initialise DAG to test
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let start_cursor_location = Path::from_vec(vec![1, 0]);
        let expected_cursor_location = Path::from_vec(vec![1]);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location);

        // Step 1: Delete TestJSON::object's child
        println!("Delete `key-value` pair");
        assert_eq!(
            Ok(EditSuccess::Delete {
                name: "field".to_string()
            }),
            editable_tree.execute_action(Action::Delete),
            "Not equal in action result."
        );
        assert_eq!(expected_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Perform one undo.
        println!("Performing undo");
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    /// This is a regression test for issue #51 (fixed in PR #53), where Sapling crashes if:
    /// 1. The user deletes the cursor when the cursor is the last child of its parent
    /// 2. The user undoes this edit
    /// 3. The user redoes this edit
    #[test]
    fn delete_cursor_crash_bug() {
        // Create and initialise DAG to test (start with JSON `[null]` with the cursor selecting
        // the `null`)
        let arena: Arena<JSON> = Arena::new();
        let root = TestJSON::Array(vec![TestJSON::Null]).add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, Path::from_vec(vec![0]));

        // Delete the node under the cursor, causing the cursor to move to the root
        assert_eq!(
            Ok(EditSuccess::Delete {
                name: "null".to_string()
            }),
            editable_tree.execute_action(Action::Delete)
        );
        assert_eq!(editable_tree.current_cursor_path, Path::root());

        // Undo this change, causing the cursor to move back to `null`
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo)
        );

        // Redo the change.  It's not really important what the tree is here, so long as the DAG
        // doesn't panic when the cursor is generated
        assert_eq!(
            Ok(EditSuccess::Redo),
            editable_tree.execute_action(Action::Redo)
        );

        let _cursor = editable_tree.cursor();
    }
}
