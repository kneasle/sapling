//! Code for an editable, undoable forest of syntax trees.

pub mod cursor;

use crate::arena::Arena;
use crate::ast;
use crate::ast::Ast;
use crate::editor::normal_mode::Action;
use cursor::Path;

/// The possible ways you can move the cursor
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Direction {
    Up,
    Down,
    Prev,
    Next,
}

/// An enum to represent the two sides of a node
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Side {
    Prev,
    Next,
}

impl Side {
    /// Converts this `Side` into either `"before"` or `"after"`
    pub fn relational_word(&self) -> &'static str {
        match self {
            Side::Prev => "before",
            Side::Next => "after",
        }
    }
}

/// An enum that's returned when any of the 'edit' methods in [`DAG`] are successful.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum EditSuccess {
    Quit,
    Undo,
    Redo,
    Move(Direction),
    Replace { c: char, name: String },
    InsertChild { c: char, name: String },
    InsertNextToCursor { side: Side, c: char, name: String },
    Delete { name: String },
}

impl EditSuccess {
    /// Writes an info message of a successful action using `info!`
    fn log_message(self) {
        match self {
            EditSuccess::Quit => log::info!("Quitting Sapling"),
            EditSuccess::Undo => log::info!("Undoing one change"),
            EditSuccess::Redo => log::info!("Redoing one change"),
            EditSuccess::Move(Direction::Up) => log::info!("Moving up the tree"),
            EditSuccess::Move(Direction::Down) => log::info!("Moving down the tree"),
            EditSuccess::Move(Direction::Prev) => log::info!("Moving to previous child"),
            EditSuccess::Move(Direction::Next) => log::info!("Moving to next child"),
            EditSuccess::Replace { c, name } => log::info!("Replacing with '{}'/{}", c, name),
            EditSuccess::InsertChild { c, name } => {
                log::info!("Inserting '{}'/{} as new child", c, name)
            }
            EditSuccess::InsertNextToCursor { side, c, name } => log::info!(
                "Inserting '{}'/{} {} the cursor",
                c,
                name,
                side.relational_word()
            ),
            EditSuccess::Delete { name } => log::info!("Deleting {}", name),
        }
    }
}

/// An error that represents an error in any of the 'edit' methods in [`DAG`].
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum EditErr {
    /* MISC ERRORS */
    /// The keystrokes that were attempted to be executed where invalid
    Invalid(String),

    /* MOVEMENT ERRORS */
    /// Trying to move to the child of a node with no children
    MoveToNonexistentChild,
    /// Trying to move to the parent of the root
    MoveToParentOfRoot,
    /// Trying to move to a sibling that doesn't exist
    MoveToNonexistentSibling,
    /// Trying to move to a sibling of the root
    MoveToSiblingOfRoot,

    /* EDITING ERRORS */
    /// Trying to undo the earliest change
    NoChangesToUndo,
    /// Trying to redo the latest change
    NoChangesToRedo,
    /// The user typed a char that doesn't correspond to any node
    CharNotANode(char),
    /// Trying to insert a node that cannot be a child of the cursor
    CannotBeChild { c: char, parent_name: String },
    /// An error was generated by the Ast code when trying to insert a node
    InsertError(ast::InsertError),
    /// An error was generated by the Ast code when trying to delete a node
    DeleteError(ast::DeleteError),
    /// Trying to add a sibling to the root
    AddSiblingToRoot,
    /// Trying to delete the root
    DeletingRoot,
}

impl EditErr {
    /// Writes an warning message of the encountered error using either `warn!` or `error!`,
    /// depending on the severity of the error
    fn log_message(self) {
        match self {
            EditErr::Invalid(keys) => log::warn!("Invalid command '{}'", keys),
            EditErr::MoveToNonexistentChild => {
                log::warn!("Can't move down if the cursor has no children.")
            }
            EditErr::MoveToNonexistentSibling => {
                log::warn!("Can't move to a non-existent sibling.")
            }
            EditErr::MoveToParentOfRoot => log::warn!("Can't move to the parent of the root."),
            EditErr::MoveToSiblingOfRoot => log::warn!("Can't move to a sibling of the root."),
            EditErr::NoChangesToUndo => log::warn!("No changes to undo."),
            EditErr::NoChangesToRedo => log::warn!("No changes to redo."),
            EditErr::InsertError(e) => log::warn!("{}", e),
            EditErr::DeleteError(e) => log::warn!("{}", e),
            EditErr::CharNotANode(c) => log::warn!("'{}' doesn't correspond to any node type.", c),
            EditErr::CannotBeChild { c, parent_name } => {
                log::warn!("'{}' cannot be a child of {}", c, parent_name)
            }
            EditErr::AddSiblingToRoot => log::warn!("Can't add siblings to the root."),
            EditErr::DeletingRoot => log::warn!("Can't delete the root."),
        }
    }
}

impl From<ast::InsertError> for EditErr {
    fn from(e: ast::InsertError) -> EditErr {
        EditErr::InsertError(e)
    }
}

impl From<ast::DeleteError> for EditErr {
    fn from(e: ast::DeleteError) -> EditErr {
        EditErr::DeleteError(e)
    }
}

/// An alias for [`Result`] that is the return type of all of [`DAG`]'s edit methods.
pub type EditResult = Result<EditSuccess, EditErr>;

/// A trait-extension that provides a convenient way convert [`EditResult`]s into log messages.
pub trait LogMessage {
    /// Log the current result's message to the appropriate log channel.
    fn log_message(self);
}

impl LogMessage for EditResult {
    /// Consumes this `EditResult` and logs an appropriate summary report (using `info!` for
    /// [`EditOk`]s and `warn!` or `error!` for [`EditErr`]s).
    fn log_message(self) {
        match self {
            Ok(ok) => ok.log_message(),
            Err(err) => err.log_message(),
        }
    }
}

/// An [`EditableTree`] that stores the history as a DAG (Directed Acyclic Graph) of **immutable**
/// nodes.
///
/// This means that every node that has ever been created exists somewhere in the DAG, and when
/// changes are made, every ancestor of that node is cloned until the root is reached and that
/// root becomes the new 'current' root.  This is very similar to the way Git stores the commits,
/// and every edit is analogous to a Git rebase.
///
/// Therefore, moving back through the history is as simple as reading a different root node from
/// the `roots` vector, and following its descendants through the DAG of nodes.
pub struct DAG<'arena, Node: Ast<'arena>> {
    /// The arena in which all the [`Node`]s will be stored
    arena: &'arena Arena<Node>,
    /// A [`Vec`] containing a reference to the root node at every edit in the undo history.  This
    /// is required to always have length at least one.
    root_history: Vec<(&'arena Node, Path)>,
    /// An index into [`root_history`](DAG::root_history) of the current edit.  This is required to
    /// be in `0..root_history.len()`.
    history_index: usize,
    current_cursor_path: Path,
}

impl<'arena, Node: Ast<'arena>> DAG<'arena, Node> {
    /// Builds a new `DAG`, given the tree it should contain
    pub fn new(arena: &'arena Arena<Node>, root: &'arena Node, cursor_path: Path) -> Self {
        DAG {
            arena,
            root_history: vec![(root, cursor_path.clone())],
            history_index: 0,
            current_cursor_path: cursor_path,
        }
    }

    /* NAVIGATION METHODS */

    /// Returns a reference to the node that is currently the root of the AST.
    pub fn root(&self) -> &'arena Node {
        // This indexing shouldn't panic because we require that `self.history_index` is a valid index
        // into `self.root_history`, and `self.root_history` has at least one element
        self.root_history[self.history_index].0
    }

    /// Returns the cursor node and its direct parent (if such a parent exists)
    pub fn cursor_and_parent(&self) -> (&'arena Node, Option<&'arena Node>) {
        self.current_cursor_path.cursor_and_parent(self.root())
    }

    /// Returns a reference to the node that is currently under the cursor.
    pub fn cursor(&self) -> &'arena Node {
        self.current_cursor_path.cursor(self.root())
    }

    /// Move the cursor in a given direction across the tree.  Returns [`Some`] error string if an
    /// error is found, or [`None`] if the movement was possible.
    pub fn move_cursor(&mut self, direction: Direction) -> EditResult {
        let (current_cursor, cursor_parent) = self.cursor_and_parent();
        match direction {
            Direction::Down => {
                if current_cursor.children().is_empty() {
                    return Err(EditErr::MoveToNonexistentChild);
                }
                self.current_cursor_path.push(0);
            }
            Direction::Up => {
                if self.current_cursor_path.is_root() {
                    return Err(EditErr::MoveToParentOfRoot);
                }
                self.current_cursor_path.pop();
            }
            Direction::Prev => {
                let index = self
                    .current_cursor_path
                    .last_mut()
                    .ok_or(EditErr::MoveToSiblingOfRoot)?;
                if *index == 0 {
                    return Err(EditErr::MoveToNonexistentSibling);
                }
                *index -= 1;
            }
            Direction::Next => {
                let last_index = self
                    .current_cursor_path
                    .last_mut()
                    .ok_or(EditErr::MoveToSiblingOfRoot)?;
                // We can unwrap here, because the only way for a node to not have a parent is
                // if it's the root.  And if the cursor is at the root, then the `if let` would
                // have failed and this code would not be run.
                if *last_index + 1 >= cursor_parent.unwrap().children().len() {
                    return Err(EditErr::MoveToNonexistentSibling);
                }
                *last_index += 1;
            }
        }
        Ok(EditSuccess::Move(direction))
    }

    /* HISTORY METHODS */

    /// Move one step back in the tree history
    pub fn undo(&mut self) -> EditResult {
        // Early return if there are no changes to undo
        if self.history_index == 0 {
            return Err(EditErr::NoChangesToUndo);
        }
        // Move the history index back by one to perform the undo
        self.history_index -= 1;
        // Follow the behaviour of other text editors and update the location of the cursor
        // with its location in the snapshot we are going back to
        self.current_cursor_path
            .clone_from(&self.root_history[self.history_index].1);
        Ok(EditSuccess::Undo)
    }

    /// Move one step forward in the tree history
    pub fn redo(&mut self) -> EditResult {
        // Early return if there are no changes to redo
        if self.history_index >= self.root_history.len() - 1 {
            return Err(EditErr::NoChangesToRedo);
        }
        // Move the history index forward by one to perform the redo
        self.history_index += 1;
        // Follow the behaviour of other text editors and update the location of the cursor
        // with its location in the snapshot we are going back to
        self.current_cursor_path
            .clone_from(&self.root_history[self.history_index].1);
        Ok(EditSuccess::Redo)
    }

    /* EDITING METHODS */

    /// Utility function to finish an edit.  This handles removing any redo history, and cloning
    /// the nodes that are parents of the node that changed.
    fn finish_edit(
        &mut self,
        nodes_to_clone: &[&'arena Node],
        steps_above_cursor: usize,
        new_node: Node,
    ) {
        // Remove future trees from the history vector so that the currently 'checked-out' tree is
        // the most recent tree in the history.
        while self.history_index < self.root_history.len() - 1 {
            // TODO: Deallocate the tree so that we don't get a 'memory leak'
            self.root_history.pop();
        }
        // Because AST nodes are immutable, we make changes to nodes by entirely cloning the path
        // down to the node under the cursor.  We do this starting at the node under the cursor and
        // work our way up parent by parent until we reach the root of the tree.  At that point,
        // this node becomes the root of the new tree.
        let mut node = self.arena.alloc(new_node);
        // SANITY CHECK: Assert that items_to_clone and self.cursor_path have the same length once
        // steps_above_cursor have been taken off - i.e. that we aren't losing any information by
        // zipping the two things together
        if nodes_to_clone.len() != self.current_cursor_path.depth() - steps_above_cursor {
            panic!(
                "`nodes_to_clone` ({:?}) has a different length to `self.cursor_path` ({:?}) with \
{} items popped.",
                nodes_to_clone, self.current_cursor_path, steps_above_cursor
            );
        }
        // Iterate backwards over the child indices and the nodes, whilst cloning the tree and
        // replacing the correct child reference to point to the newly created node.
        for (n, child_index) in nodes_to_clone.iter().rev().zip(
            self.current_cursor_path
                .iter()
                .rev()
                .skip(steps_above_cursor),
        ) {
            let mut cloned_node = (*n).clone();
            cloned_node.children_mut()[*child_index] = node;
            node = self.arena.alloc(cloned_node);
        }
        // At this point, `node` contains a reference to the root of the new tree, so we just add
        // this to the history, along with the cursor path.
        self.root_history
            .push((node, self.current_cursor_path.clone()));
        // Move the history index on by one so that we are pointing at the latest change
        self.history_index = self.root_history.len() - 1;
    }

    /// Replaces the current cursor with a node represented by `c`
    fn replace_cursor(&mut self, c: char) -> EditResult {
        /* CHECK THE VALIDITY OF ARGUMENTS */

        // Cache the node under the cursor, since finding the cursor involves non-trivial amounts
        // of work
        let cursor = self.cursor();
        // Short circuit if the char to insert couldn't correspond to a valid child
        if !cursor.is_replace_char(c) {
            return Err(EditErr::CannotBeChild {
                c,
                // TODO: Get the parent name
                parent_name: "<unknown>".to_string(),
            });
        }

        /* PERFORM THE ACTION */

        let new_node = cursor.from_char(c).ok_or(EditErr::CharNotANode(c))?;
        // Generate a vec of pointers to the nodes that we will have to clone.  We have to store
        // this as a vec because the iterator that produces them (cursor_path::NodeIter) can only
        // yield values from the root downwards, whereas we need the nodes in the opposite order.
        let mut nodes_to_clone: Vec<_> = self.current_cursor_path.node_iter(self.root()).collect();
        // The last value of nodes_to_clone is the node under the cursor, which we do not need to
        // clone, so we pop that reference.
        assert!(nodes_to_clone.pop().is_some());

        /* FINISH THE EDIT AND RETURN SUCCESS */

        // Store the new_node's display name before it's consumed by `finish_edit`
        let new_node_name = new_node.display_name();
        self.finish_edit(&nodes_to_clone, 0, new_node);
        Ok(EditSuccess::Replace {
            c,
            name: new_node_name,
        })
    }

    /// Updates the internal state so that the tree now contains `new_node` inserted as the last
    /// child of the selected node.  Also moves the cursor so that the new node is selected.
    fn insert_child(&mut self, c: char) -> EditResult {
        /* CHECK THE VALIDITY OF ARGUMENTS */

        // Cache the node under the cursor, since finding the cursor involves non-trivial amounts
        // of work
        let cursor = self.cursor();
        // Short circuit if `c` couldn't be a valid child of the cursor
        if !cursor.is_insert_char(c) {
            return Err(EditErr::CannotBeChild {
                c,
                parent_name: cursor.display_name(),
            });
        }

        /* PERFORM THE ACTION */

        let new_node = self
            .arena
            .alloc(cursor.from_char(c).ok_or(EditErr::CharNotANode(c))?);
        // Generate a vec of pointers to the nodes that we will have to clone.  We have to store
        // this as a vec because the iterator that produces them (cursor_path::NodeIter) can only
        // yield values from the root downwards, whereas we need the nodes in the opposite order.
        let mut nodes_to_clone: Vec<_> = self.current_cursor_path.node_iter(self.root()).collect();
        // Clone the node that currently is the cursor, and add the new child to the end of its
        // children.  Unwrapping here is fine, because `cursor_path::NodeIter` will always return
        // one value.
        let mut cloned_cursor = nodes_to_clone.pop().unwrap().clone();
        // Store the new_node's display name before it's consumed by `finish_edit`
        let new_node_name = new_node.display_name();
        // Add the new child to the children of the cloned cursor
        cloned_cursor.insert_child(new_node, self.arena, cloned_cursor.children().len())?;

        /* FINISH THE EDIT AND RETURN SUCCESS */

        self.finish_edit(&nodes_to_clone, 0, cloned_cursor);
        Ok(EditSuccess::InsertChild {
            c,
            name: new_node_name,
        })
    }

    /// Updates the internal state so that the tree now contains `new_node` inserted as the first
    /// child of the selected node.  Also moves the cursor so that the new node is selected.
    fn insert_next_to_cursor(&mut self, c: char, side: Side) -> EditResult {
        /* CHECK VALIDITY OF ARGUMENTS */

        // Find (and cache) the parent of the cursor.  If the parent of the cursor doesn't exist,
        // the cursor must be the root and we can't insert a node next to the root.
        let parent = match self.cursor_and_parent().1 {
            None => return Err(EditErr::AddSiblingToRoot),
            Some(p) => p,
        };
        // Short circuit if not an insertable char
        if !parent.is_insert_char(c) {
            return Err(EditErr::CannotBeChild {
                c,
                parent_name: parent.display_name(),
            });
        }

        /* PERFORM THE INSERTION */

        // Generate a vec of pointers to the nodes that we will have to clone.  We have to store
        // this as a vec because the iterator that produces them (cursor_path::NodeIter) can only
        // yield values from the root downwards, whereas we need the nodes in the opposite order.
        let mut nodes_to_clone: Vec<_> = self.current_cursor_path.node_iter(self.root()).collect();
        // Pop the cursor, because it will be unchanged.  The only part of this that we need is
        // the cursor's index.
        assert!(nodes_to_clone.pop().is_some());
        // Find the index of the cursor, so that we know where to insert.  We can unwrap, because
        // if we were at the root, then we'd early return from the if statement above
        let cursor_sibling_index = *self.current_cursor_path.last_mut().unwrap();
        let insert_index = cursor_sibling_index
            + match side {
                Side::Prev => 0,
                Side::Next => 1,
            };
        // Clone the node that currently is the cursor, and add the new child to the end of its
        // children.  Unwrapping here is fine, because `cursor_path::NodeIter` will always
        // return one value.
        let mut cloned_parent = nodes_to_clone.pop().unwrap().clone();
        // Create the new child node according to the given char.
        let new_child_node = self
            .arena
            .alloc(cloned_parent.from_char(c).ok_or(EditErr::CharNotANode(c))?);
        // Store the new_node's display name before it's consumed by `insert_child`
        let new_node_name = new_child_node.display_name();
        // Add the new child to the children of the cloned cursor
        cloned_parent.insert_child(new_child_node, self.arena, insert_index)?;

        /* FINISH THE EDIT AND RETURN SUCCESS */

        // Finish the edit and update the history
        self.finish_edit(&nodes_to_clone, 1, cloned_parent);
        // Return the success
        Ok(EditSuccess::InsertNextToCursor {
            side,
            c,
            name: new_node_name,
        })
    }

    fn delete_cursor(&mut self) -> EditResult {
        /* CHECK VALIDITY OF ARGUMENTS */

        // Generate a vec of pointers to the nodes that we will have to clone.  We have to store
        // this as a vec because the iterator that produces them (cursor_path::NodeIter) can only
        // yield values from the root downwards, whereas we need the nodes in the opposite order.
        let mut nodes_to_clone: Vec<_> = self.current_cursor_path.node_iter(self.root()).collect();
        // Pop the cursor, because it will be unchanged.  We can unwrap here, because
        // `Path::node_iter` will always yield at least one node (the first value returned is
        // a reference to the root).
        let deleted_node_name = nodes_to_clone.pop().unwrap().display_name();
        // Short circuit if we're trying to delete the root
        if nodes_to_clone.is_empty() {
            return Err(EditErr::DeletingRoot);
        }

        /* PERFORM THE INSERTION */

        // Find the index of the cursor, so that we know where to delete.  We can unwrap, because
        // if we were at the root, then we'd early return from the if statement above.
        let cursor_sibling_index = *self.current_cursor_path.last_mut().unwrap();
        let mut cloned_parent = nodes_to_clone.pop().unwrap().clone();
        cloned_parent.delete_child(cursor_sibling_index)?;
        // Cache this so that we can
        let new_parents_child_count = cloned_parent.children().len();

        /* FINISH THE EDIT AND RETURN SUCCESS */

        self.finish_edit(&nodes_to_clone, 1, cloned_parent);

        /* MOVE THE CURSOR TO THE NEAREST VALID NODE */

        // IMPORTANTLY, we move the cursor **AFTER** calling `self.finish_edit`, because
        // `self.finish_edit` reads the cursor path

        // If we remove the only child of a node then we move the cursor up
        if new_parents_child_count == 0 {
            self.current_cursor_path.pop();
        } else {
            // If we deleted the last child of a node (and this isn't the last child), we move
            // the cursor back by one
            if cursor_sibling_index == new_parents_child_count {
                // We can unwrap here because we know we aren't removing the root
                *self.current_cursor_path.last_mut().unwrap() -= 1;
            }
        }
        Ok(EditSuccess::Delete {
            name: deleted_node_name,
        })
    }

    /// Execute an [`Action`] generated by user's keystrokes.  Returns `true` if the user executed
    /// [`Action::Quit`], false otherwise
    pub fn execute_action(&mut self, action: Action) -> (bool, EditResult) {
        let mut should_quit = false;
        // Respond to the action
        let result = match action {
            // Undefined keystroke
            Action::Undefined(keys) => Err(EditErr::Invalid(keys)),
            // History keystrokes
            Action::Undo => self.undo(),
            Action::Redo => self.redo(),
            // Move keystroke
            Action::MoveCursor(direction) => self.move_cursor(direction),
            // Edit keystrokes
            Action::Replace(c) => self.replace_cursor(c),
            Action::InsertChild(c) => self.insert_child(c),
            Action::InsertBefore(c) => self.insert_next_to_cursor(c, Side::Prev),
            Action::InsertAfter(c) => self.insert_next_to_cursor(c, Side::Next),
            Action::Delete => self.delete_cursor(),
            // Quit Sapling
            Action::Quit => {
                should_quit = true;
                Ok(EditSuccess::Quit)
            }
        };
        (should_quit, result)
    }

    /* DISPLAY METHODS */

    /// Build the text representation of the current tree into the given [`String`]
    pub fn write_text(&self, string: &mut String, format: &Node::FormatStyle) {
        self.root().write_text(string, format);
    }

    /// Build and return a [`String`] of the current tree
    pub fn to_text(&self, format: &Node::FormatStyle) -> String {
        let mut s = String::new();
        self.write_text(&mut s, format);
        s
    }
}

#[cfg(test)]
mod tests {
    use super::{cursor::Path, Direction, EditErr, EditSuccess, Side, DAG};
    use crate::arena::Arena;
    use crate::ast::json::JSON;
    use crate::ast::test_json::TestJSON;
    use crate::editor::normal_mode::Action;

    fn run_test_ok(
        start_tree: TestJSON,
        start_cursor_location: Path,
        action: Action,
        expected_edit_result: (bool, Result<EditSuccess, EditErr>),
        expected_tree: TestJSON,
        expected_cursor_location: Path,
    ) {
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location);

        assert_eq!(
            expected_edit_result,
            editable_tree.execute_action(action),
            "Not equal in action result"
        );
        assert_eq!(expected_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    fn run_test_err(
        start_tree: TestJSON,
        start_cursor_location: Path,
        action: Action,
        expected_edit_result: (bool, Result<EditSuccess, EditErr>),
    ) {
        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.clone().add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location.clone());

        assert_eq!(
            expected_edit_result,
            editable_tree.execute_action(action),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            start_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    #[test]
    fn dag_root_insertchild() {
        run_test_ok(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::InsertChild('f'),
            (
                false,
                Ok(EditSuccess::InsertChild {
                    c: 'f',
                    name: "false".to_string(),
                }),
            ),
            TestJSON::Array(vec![TestJSON::False]),
            Path::root(),
        );

        //DAG level == 1

        run_test_ok(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::InsertChild('n'),
            (
                false,
                Ok(EditSuccess::InsertChild {
                    c: 'n',
                    name: "null".to_string(),
                }),
            ),
            TestJSON::Array(vec![
                TestJSON::Array(vec![]),
                TestJSON::True,
                TestJSON::Null,
            ]),
            Path::root(),
        )
    }

    #[test]
    fn dag_root_insertbefore() {
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::InsertBefore('f'),
            (false, Err(EditErr::AddSiblingToRoot)),
        );

        //  tree level == 1
        run_test_err(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::InsertBefore('f'),
            (false, Err(EditErr::AddSiblingToRoot)),
        );
    }

    #[test]
    fn dag_root_insertafter() {
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::InsertAfter('f'),
            (false, Err(EditErr::AddSiblingToRoot)),
        );

        // tree level == 1
        run_test_err(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::InsertAfter('f'),
            (false, Err(EditErr::AddSiblingToRoot)),
        );
    }

    #[test]
    fn dag_root_repalce() {
        run_test_ok(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::Replace('f'),
            (
                false,
                Ok(EditSuccess::Replace {
                    c: 'f',
                    name: "false".to_string(),
                }),
            ),
            TestJSON::False,
            Path::root(),
        );

        // Char not a node
        run_test_err(
            TestJSON::False,
            Path::root(),
            Action::Replace('m'),
            (
                false,
                Err(EditErr::CannotBeChild {
                    c: 'm',
                    parent_name: "<unknown>".to_string(),
                }),
            ),
        );
        //
        // tree level == 1
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Array(vec![])]),
            Path::root(),
            Action::Replace('n'),
            (
                false,
                Ok(EditSuccess::Replace {
                    c: 'n',
                    name: "null".to_string(),
                }),
            ),
            TestJSON::Null,
            Path::root(),
        );
    }

    #[test]
    fn dag_root_undefined() {
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::Undefined("c".to_string()),
            (false, Err(EditErr::Invalid("c".to_string()))),
        );
    }

    #[test]
    fn dag_root_delete() {
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::Delete,
            (false, Err(EditErr::DeletingRoot)),
        );

        // dag level==1
        run_test_err(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::root(),
            Action::Delete,
            (false, Err(EditErr::DeletingRoot)),
        );
    }

    #[test]
    fn dag_root_movecursor() {
        // move to previous sibling node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Prev),
            (false, Err(EditErr::MoveToSiblingOfRoot)),
        );
        // move to next sibling node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Next),
            (false, Err(EditErr::MoveToSiblingOfRoot)),
        );
        // move to parent node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Up),
            (false, Err(EditErr::MoveToParentOfRoot)),
        );
        // move to nonexistent child node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            (false, Err(EditErr::MoveToNonexistentChild)),
        );

        // move to nonexistent child node of root
        run_test_err(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            (false, Err(EditErr::MoveToNonexistentChild)),
        );
        // move to root from child
        run_test_ok(
            TestJSON::Array(vec![TestJSON::False, TestJSON::True]),
            Path::from_vec(vec![1]),
            Action::MoveCursor(Direction::Up),
            (false, Ok(EditSuccess::Move(Direction::Up))),
            TestJSON::Array(vec![TestJSON::False, TestJSON::True]),
            Path::root(),
        );
    }

    #[test]
    fn dag_root_quit() {
        run_test_ok(
            TestJSON::Array(vec![]),
            Path::root(),
            Action::Quit,
            (true, Ok(EditSuccess::Quit)),
            TestJSON::Array(vec![]),
            Path::root(),
        );
    }

    #[test]
    fn dag_root_undo() {
        let start_tree = TestJSON::Array(vec![]);
        let start_cursor_location_0 = Path::root();

        let action_0 = Action::Replace('f');
        let action_1 = Action::Undo;

        let expected_edit_result_0: (bool, Result<EditSuccess, EditErr>) = (
            false,
            Ok(EditSuccess::Replace {
                c: 'f',
                name: "false".to_string(),
            }),
        );
        let expected_edit_result_1: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Undo));

        let expected_tree_0 = TestJSON::False;
        let expected_tree_1 = TestJSON::Array(vec![]);

        let expected_cursor_location_0 = Path::root();
        let expected_cursor_location_1 = Path::root();

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location_0);

        assert_eq!(
            expected_edit_result_0,
            editable_tree.execute_action(action_0),
            "Not equal in action result"
        );
        assert_eq!(expected_tree_0, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location_0, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // undo
        assert_eq!(
            expected_edit_result_1,
            editable_tree.execute_action(action_1),
            "Not equal in action result"
        );
        assert_eq!(expected_tree_1, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location_1, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        //  DAG level == 1
        let start_tree = TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let start_cursor_location_0 = Path::root();

        let action_0 = Action::MoveCursor(Direction::Down);
        let action_1 = Action::Undo;

        let expected_edit_result_0: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Move(Direction::Down)));
        let expected_edit_result_1: (bool, Result<EditSuccess, EditErr>) =
            (false, Err(EditErr::NoChangesToUndo));

        let expected_tree_0 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let expected_tree_1 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);

        let expected_cursor_location_0 = Path::from_vec(vec![0]);
        let expected_cursor_location_1 = Path::from_vec(vec![0]);

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location_0);

        assert_eq!(
            expected_edit_result_0,
            editable_tree.execute_action(action_0),
            "Not equal in action result (move 0)."
        );
        assert_eq!(
            expected_tree_0,
            editable_tree.root(),
            "Not equal in tree (move 0)."
        );
        assert_eq!(
            expected_cursor_location_0, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 0)."
        );

        // undo
        assert_eq!(
            expected_edit_result_1,
            editable_tree.execute_action(action_1),
            "Not equal in action result (move 1)"
        );
        assert_eq!(
            expected_tree_1,
            editable_tree.root(),
            "Not equal in tree (move 1)."
        );
        assert_eq!(
            expected_cursor_location_1, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 1)."
        );
    }

    #[test]
    fn dag_root_redo() {
        let start_tree = TestJSON::Array(vec![]);
        let start_cursor_location_0 = Path::root();

        let action_0 = Action::Replace('o');
        let action_1 = Action::Undo;
        let action_2 = Action::Redo;

        let expected_edit_result_0: (bool, Result<EditSuccess, EditErr>) = (
            false,
            Ok(EditSuccess::Replace {
                c: 'o',
                name: "object".to_string(),
            }),
        );
        let expected_edit_result_1: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Undo));
        let expected_edit_result_2: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Redo));

        let expected_tree_0 = TestJSON::Object(vec![]);
        let expected_tree_1 = TestJSON::Array(vec![]);
        let expected_tree_2 = TestJSON::Object(vec![]);

        let expected_cursor_location_0 = Path::root();
        let expected_cursor_location_1 = Path::root();
        let expected_cursor_location_2 = Path::root();

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location_0);

        assert_eq!(
            expected_edit_result_0,
            editable_tree.execute_action(action_0),
            "Not equal in action result"
        );
        assert_eq!(expected_tree_0, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location_0, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // undo
        assert_eq!(
            expected_edit_result_1,
            editable_tree.execute_action(action_1),
            "Not equal in action result"
        );
        assert_eq!(expected_tree_1, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location_1, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // redo
        assert_eq!(
            expected_edit_result_2,
            editable_tree.execute_action(action_2),
            "Not equal in action result"
        );
        assert_eq!(expected_tree_2, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location_2, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        //DAG level == 1
        let start_tree = TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let start_cursor_location_0 = Path::root();

        let action_0 = Action::MoveCursor(Direction::Down);
        let action_1 = Action::Undo;
        let action_2 = Action::Redo;

        let expected_edit_result_0: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Move(Direction::Down)));
        let expected_edit_result_1: (bool, Result<EditSuccess, EditErr>) =
            (false, Err(EditErr::NoChangesToUndo));
        let expected_edit_result_2: (bool, Result<EditSuccess, EditErr>) =
            (false, Err(EditErr::NoChangesToRedo));

        let expected_tree_0 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let expected_tree_1 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let expected_tree_2 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);

        let expected_cursor_location_0 = Path::from_vec(vec![0]);
        let expected_cursor_location_1 = Path::from_vec(vec![0]);
        let expected_cursor_location_2 = Path::from_vec(vec![0]);

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location_0);

        assert_eq!(
            expected_edit_result_0,
            editable_tree.execute_action(action_0),
            "Not equal in action result (move 0)."
        );
        assert_eq!(
            expected_tree_0,
            editable_tree.root(),
            "Not equal in tree (move 0)."
        );
        assert_eq!(
            expected_cursor_location_0, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 0)."
        );

        // undo
        assert_eq!(
            expected_edit_result_1,
            editable_tree.execute_action(action_1),
            "Not equal in action result (move 1)."
        );
        assert_eq!(
            expected_tree_1,
            editable_tree.root(),
            "Not equal in tree (move 1)."
        );
        assert_eq!(
            expected_cursor_location_1, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 1). "
        );

        // redo
        assert_eq!(
            expected_edit_result_2,
            editable_tree.execute_action(action_2),
            "Not equal in action result (move 2)."
        );
        assert_eq!(
            expected_tree_2,
            editable_tree.root(),
            "Not equal in tree (move 2)."
        );
        assert_eq!(
            expected_cursor_location_2, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 2)."
        );
    }

    #[test]
    fn dag_level_1_insertchild() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::from_vec(vec![0]),
            Action::InsertChild('f'),
            (
                false,
                Ok(EditSuccess::InsertChild {
                    c: 'f',
                    name: "false".to_string(),
                }),
            ),
            TestJSON::Array(vec![TestJSON::Array(vec![TestJSON::False]), TestJSON::True]),
            Path::from_vec(vec![0]),
        );
    }

    #[test]
    fn dag_level_1_insertafter() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::from_vec(vec![0]),
            Action::InsertAfter('f'),
            (
                false,
                Ok(EditSuccess::InsertNextToCursor {
                    side: Side::Next,
                    c: 'f',
                    name: "false".to_string(),
                }),
            ),
            TestJSON::Array(vec![
                TestJSON::Array(vec![]),
                TestJSON::False,
                TestJSON::True,
            ]),
            Path::from_vec(vec![0]),
        );

        // DAG level == 2
        run_test_ok(
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
            ]),
            Path::from_vec(vec![1]),
            Action::InsertAfter('f'),
            (
                false,
                Ok(EditSuccess::InsertNextToCursor {
                    side: Side::Next,
                    c: 'f',
                    name: "false".to_string(),
                }),
            ),
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
                TestJSON::False,
            ]),
            Path::from_vec(vec![1]),
        );
    }

    #[test]
    fn dag_level_1_insertbefore() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::Array(vec![]), TestJSON::True]),
            Path::from_vec(vec![0]),
            Action::InsertBefore('f'),
            (
                false,
                Ok(EditSuccess::InsertNextToCursor {
                    side: Side::Prev,
                    c: 'f',
                    name: "false".to_string(),
                }),
            ),
            TestJSON::Array(vec![
                TestJSON::False,
                TestJSON::Array(vec![]),
                TestJSON::True,
            ]),
            Path::from_vec(vec![0]),
        );

        // DAG level == 2
        run_test_ok(
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
            ]),
            Path::from_vec(vec![1]),
            Action::InsertBefore('f'),
            (
                false,
                Ok(EditSuccess::InsertNextToCursor {
                    side: Side::Prev,
                    c: 'f',
                    name: "false".to_string(),
                }),
            ),
            TestJSON::Array(vec![
                TestJSON::Array(vec![TestJSON::Null, TestJSON::True]),
                TestJSON::False,
                TestJSON::Object(vec![("value".to_string(), TestJSON::True)]),
            ]),
            Path::from_vec(vec![1]),
        );
    }

    #[test]
    fn dag_level_1_delete() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Array(vec![])]),
            Path::from_vec(vec![1]),
            Action::Delete,
            (
                false,
                Ok(EditSuccess::Delete {
                    name: "array".to_string(),
                }),
            ),
            TestJSON::Array(vec![TestJSON::True]),
            Path::from_vec(vec![0]),
        );

        run_test_ok(
            TestJSON::Array(vec![TestJSON::True]),
            Path::from_vec(vec![0]),
            Action::Delete,
            (
                false,
                Ok(EditSuccess::Delete {
                    name: "true".to_string(),
                }),
            ),
            TestJSON::Array(vec![]),
            Path::root(),
        );
    }

    #[test]
    fn dag_level_1_replace() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Array(vec![])]),
            Path::from_vec(vec![1]),
            Action::Replace('n'),
            (
                false,
                Ok(EditSuccess::Replace {
                    c: 'n',
                    name: "null".to_string(),
                }),
            ),
            TestJSON::Array(vec![TestJSON::True, TestJSON::Null]),
            Path::from_vec(vec![1]),
        );
    }

    #[test]
    fn dag_level_1_undefined() {
        run_test_err(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Object(vec![])]),
            Path::from_vec(vec![1]),
            Action::Undefined("f".to_string()),
            (false, Err(EditErr::Invalid("f".to_string()))),
        );
    }

    #[test]
    fn dag_level_1_movecursor() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Object(vec![])]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            (false, Ok(EditSuccess::Move(Direction::Down))),
            TestJSON::Array(vec![TestJSON::True, TestJSON::Object(vec![])]),
            Path::from_vec(vec![0]),
        );
    }

    #[test]
    fn dag_level_1_undo() {
        let start_tree = TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let start_cursor_location_0 = Path::root();

        let action_0 = Action::Replace('f');
        let action_1 = Action::Undo;

        let expected_edit_result_0: (bool, Result<EditSuccess, EditErr>) = (
            false,
            Ok(EditSuccess::Replace {
                c: 'f',
                name: "false".to_string(),
            }),
        );
        let expected_edit_result_1: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Undo));

        let expected_tree_0 = TestJSON::False;
        let expected_tree_1 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);

        let expected_cursor_location_0 = Path::root();
        let expected_cursor_location_1 = Path::root();

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location_0);

        assert_eq!(
            expected_edit_result_0,
            editable_tree.execute_action(action_0),
            "Not equal in action result"
        );
        assert_eq!(expected_tree_0, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location_0, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // undo
        assert_eq!(
            expected_edit_result_1,
            editable_tree.execute_action(action_1),
            "Not equal in action result"
        );
        assert_eq!(expected_tree_1, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location_1, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    #[test]
    fn dag_level_1_redo() {
        let start_tree = TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let start_cursor_location_0 = Path::root();

        let action_0 = Action::Replace('f');
        let action_1 = Action::Undo;
        let action_2 = Action::Undo;
        let action_3 = Action::Redo;
        let action_4 = Action::Redo;

        let expected_edit_result_0: (bool, Result<EditSuccess, EditErr>) = (
            false,
            Ok(EditSuccess::Replace {
                c: 'f',
                name: "false".to_string(),
            }),
        );
        let expected_edit_result_1: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Undo));

        let expected_edit_result_2: (bool, Result<EditSuccess, EditErr>) =
            (false, Err(EditErr::NoChangesToUndo));

        let expected_edit_result_3: (bool, Result<EditSuccess, EditErr>) =
            (false, Ok(EditSuccess::Redo));

        let expected_edit_result_4: (bool, Result<EditSuccess, EditErr>) =
            (false, Err(EditErr::NoChangesToRedo));

        let expected_tree_0 = TestJSON::False;
        let expected_tree_1 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let expected_tree_2 =
            TestJSON::Array(vec![TestJSON::Null, TestJSON::True, TestJSON::False]);
        let expected_tree_3 = TestJSON::False;
        let expected_tree_4 = TestJSON::False;

        let expected_cursor_location_0 = Path::root();
        let expected_cursor_location_1 = Path::root();
        let expected_cursor_location_2 = Path::root();
        let expected_cursor_location_3 = Path::root();
        let expected_cursor_location_4 = Path::root();

        let arena: Arena<JSON> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = DAG::new(&arena, root, start_cursor_location_0);

        assert_eq!(
            expected_edit_result_0,
            editable_tree.execute_action(action_0),
            "Not equal in action result (move 0)."
        );
        assert_eq!(
            expected_tree_0,
            editable_tree.root(),
            "Not equal in tree (move 0)."
        );
        assert_eq!(
            expected_cursor_location_0, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 0)."
        );

        // undo 1
        assert_eq!(
            expected_edit_result_1,
            editable_tree.execute_action(action_1),
            "Not equal in action result (move 1)"
        );
        assert_eq!(
            expected_tree_1,
            editable_tree.root(),
            "Not equal in tree (move 1)."
        );
        assert_eq!(
            expected_cursor_location_1, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 1)."
        );

        // undo 2
        assert_eq!(
            expected_edit_result_2,
            editable_tree.execute_action(action_2),
            "Not equal in action result (move 2)"
        );
        assert_eq!(
            expected_tree_2,
            editable_tree.root(),
            "Not equal in tree (move 2)."
        );
        assert_eq!(
            expected_cursor_location_2, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 2)."
        );

        // redo 1
        assert_eq!(
            expected_edit_result_3,
            editable_tree.execute_action(action_3),
            "Not equal in action result (move 3)"
        );
        assert_eq!(
            expected_tree_3,
            editable_tree.root(),
            "Not equal in tree (move 3)."
        );
        assert_eq!(
            expected_cursor_location_3, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 3)."
        );

        // redo 2
        assert_eq!(
            expected_edit_result_4,
            editable_tree.execute_action(action_4),
            "Not equal in action result (move 4)"
        );
        assert_eq!(
            expected_tree_4,
            editable_tree.root(),
            "Not equal in tree (move 4)."
        );
        assert_eq!(
            expected_cursor_location_4, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 4)."
        );
    }

    #[test]
    fn dag_level_1_quit() {
        run_test_ok(
            TestJSON::Array(vec![TestJSON::True, TestJSON::Object(vec![])]),
            Path::from_vec(vec![0]),
            Action::Quit,
            (true, Ok(EditSuccess::Quit)),
            TestJSON::Array(vec![TestJSON::True, TestJSON::Object(vec![])]),
            Path::from_vec(vec![0]),
        );
    }
}
